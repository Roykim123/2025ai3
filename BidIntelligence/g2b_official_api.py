#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
G2B Í≥µÏãù API ÏÜîÎ£®ÏÖò - Ï°∞Îã¨Ï≤≠ ÎÇòÎùºÏû•ÌÑ∞ ÏûÖÏ∞∞Í≥µÍ≥†Ï†ïÎ≥¥ÏÑúÎπÑÏä§
Official G2B API Solution using Public Data Portal

Based on official documentation:
- Service: BidPublicInfoService
- Endpoint: https://apis.data.go.kr/1230000/ad/BidPublicInfoService
- Operations: Î¨ºÌíà, Ïö©Ïó≠, Í≥µÏÇ¨, Ïô∏Ïûê ÏûÖÏ∞∞Í≥µÍ≥† Ï°∞Ìöå
"""

import os
import sys
import requests
import pandas as pd
import xml.etree.ElementTree as ET
import json
from datetime import datetime, timedelta
from typing import Optional, Dict, List
from urllib.parse import quote

# Configuration
SEARCH_DAYS = 7
OUTPUT_DIR = "output"

# Official API Configuration (from documentation)
API_BASE_URL = "https://apis.data.go.kr/1230000/ad/BidPublicInfoService"

# Available operations
API_OPERATIONS = {
    'construction': 'getBidPblancListInfoCnstwkPPSSrch',  # Í≥µÏÇ¨ Ï°∞Ìöå
    'service': 'getBidPblancListInfoServcPPSSrch',        # Ïö©Ïó≠ Ï°∞Ìöå  
    'goods': 'getBidPblancListInfoThngPPSSrch',           # Î¨ºÌíà Ï°∞Ìöå
    'foreign': 'getBidPblancListInfoFrgcptPPSSrch'        # Ïô∏Ïûê Ï°∞Ìöå
}

def get_api_key() -> Optional[str]:
    """Get API key from environment or user input"""
    # Try environment variable first
    api_key = os.getenv('G2B_API_KEY')
    if api_key:
        print(f"‚úì Using API key from environment variable")
        return api_key
    
    # Try hardcoded keys provided by user
    provided_keys = [
        "holAgj%2F0G%2B0f0COeMdfrl%2B0iDpm1lSzmYMlYxmMYq%2F7vkjMMFWZMMBZ6cReG%2B1VhhyIdN%2FpgykHNXwlkSYSZ%2Fw%3D%3D",  # Encoded
        "holAgj/0G+0f0COeMdfrl+0iDpm1lSzmYMlYxmMYq/7vkjMMFWZMMBZ6cReG+1VhhyIdN/pgykHNXwlkSYSZ/w=="   # Decoded
    ]
    
    for key in provided_keys:
        if key:
            print(f"‚úì Using provided API key")
            return key
    
    print("‚ùå No API key found")
    print("üí° Please set G2B_API_KEY environment variable or provide API key")
    return None

def call_g2b_api(operation: str, params: Dict) -> Optional[Dict]:
    """Call G2B API with specified operation and parameters"""
    try:
        url = f"{API_BASE_URL}/{operation}"
        
        print(f"üîó Calling API: {operation}")
        
        # Enhanced headers for better compatibility
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'application/xml, text/xml, */*',
            'Accept-Language': 'ko-KR,ko;q=0.9,en;q=0.8',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive'
        }
        
        # Use decoded API key
        if 'serviceKey' in params:
            # Try decoded key first
            decoded_key = "holAgj/0G+0f0COeMdfrl+0iDpm1lSzmYMlYxmMYq/7vkjMMFWZMMBZ6cReG+1VhhyIdN/pgykHNXwlkSYSZ/w=="
            params['serviceKey'] = decoded_key
        
        print(f"üìã Using decoded API key")
        
        # Make API request with SSL verification disabled and enhanced session
        session = requests.Session()
        session.headers.update(headers)
        
        response = session.get(
            url, 
            params=params, 
            timeout=30,
            verify=False,  # Disable SSL verification for Replit compatibility
            allow_redirects=True
        )
        
        print(f"üì° Response status: {response.status_code}")
        
        if response.status_code != 200:
            print(f"‚ùå HTTP Error: {response.status_code}")
            print(f"Response: {response.text[:500]}")
            return None
        
        print(f"‚úÖ API call successful, response size: {len(response.content)} bytes")
        
        # Parse response based on type
        if params.get('type', '').lower() == 'json':
            try:
                return response.json()
            except json.JSONDecodeError as e:
                print(f"‚ùå JSON parsing error: {e}")
                print(f"Response text: {response.text[:500]}")
                return None
        else:
            # Default XML parsing
            try:
                root = ET.fromstring(response.content)
                return {'xml_root': root, 'raw_response': response.text}
            except ET.ParseError as e:
                print(f"‚ùå XML parsing error: {e}")
                print(f"Response text: {response.text[:500]}")
                return None
                
    except requests.exceptions.SSLError as e:
        print(f"‚ùå SSL Error: {e}")
        print("üí° This may be due to network restrictions in the current environment")
        return None
    except requests.exceptions.RequestException as e:
        print(f"‚ùå Network error: {e}")
        return None
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")
        return None

def parse_xml_response(xml_root) -> List[Dict]:
    """Parse XML response to extract bid information"""
    try:
        # Check response status
        result_code = xml_root.find('.//resultCode')
        result_msg = xml_root.find('.//resultMsg')
        
        if result_code is not None and result_code.text != '00':
            error_msg = result_msg.text if result_msg is not None else 'Unknown error'
            print(f"‚ùå API Error: {error_msg}")
            return []
        
        # Extract total count
        total_count = xml_root.find('.//totalCount')
        total = int(total_count.text) if total_count is not None and total_count.text else 0
        print(f"üìä Total announcements available: {total}")
        
        # Extract items
        items = xml_root.findall('.//item')
        print(f"üìã Processing {len(items)} items in current page")
        
        if not items:
            print("‚ÑπÔ∏è No items found in response")
            return []
        
        bid_data = []
        excluded_count = 0
        
        for item in items:
            try:
                # Helper function to safely extract text
                def get_text(tag_name: str) -> str:
                    elem = item.find(tag_name)
                    return elem.text.strip() if elem is not None and elem.text else 'Ï†ïÎ≥¥ÏóÜÏùå'
                
                # Extract basic information
                contract_method = get_text('cntrctCnclsMthdNm')
                bid_number = get_text('bidNtceNo')
                
                # Filter out private contracts (ÏàòÏùòÍ≥ÑÏïΩ)
                if 'ÏàòÏùòÍ≥ÑÏïΩ' in contract_method:
                    excluded_count += 1
                    continue
                
                # Build bid information dictionary
                bid_info = {
                    'Í≥µÍ≥†Î™Ö': get_text('bidNtceNm'),
                    'Í≥µÍ≥†Î≤àÌò∏': bid_number,
                    'Í≥µÍ≥†Í∏∞Í¥Ä': get_text('ntceInsttNm'),
                    'ÏàòÏöîÍ∏∞Í¥Ä': get_text('dminsttNm'),
                    'Í≥ÑÏïΩÎ∞©Î≤ï': contract_method,
                    'ÏûÖÏ∞∞Í≥µÍ≥†Ïùº': get_text('bidNtceDt'),
                    'ÏûÖÏ∞∞ÎßàÍ∞êÏùºÏãú': get_text('bidClseDt') if get_text('bidClseDt') != 'Ï†ïÎ≥¥ÏóÜÏùå' else 'Ï†ïÎ≥¥ÏóÜÏùå',
                    'Í∞úÏ∞∞ÏùºÏãú': get_text('opengDt') if get_text('opengDt') != 'Ï†ïÎ≥¥ÏóÜÏùå' else 'Ï†ïÎ≥¥ÏóÜÏùå',
                    'ÏòàÏ†ïÍ∞ÄÍ≤©': get_text('presmptPrc'),
                    'Ï∂îÏ†ïÍ∞ÄÍ≤©': get_text('assmtUprc'),
                    'ÎÇôÏ∞∞ÌïòÌïúÏú®': get_text('scsbdAmt'),
                    'Ï∞∏Í∞ÄÏûêÍ≤©': get_text('prtcptLmtYn'),
                    'ÏßÄÏó≠Ï†úÌïú': get_text('rgstTyNm'),
                    'ÏóÖÏ¢ÖÏ†úÌïú': get_text('indstryClNm'),
                    'ÏûÖÏ∞∞Î∞©Ïãù': get_text('bidMethdNm'),
                    'Í≥µÍ≥†Ï¢ÖÎ•ò': get_text('ntceKindNm'),
                    'Íµ≠Ï†úÏûÖÏ∞∞Ïó¨Î∂Ä': get_text('intrbidYn'),
                    'Ïû¨Í≥µÍ≥†Ïó¨Î∂Ä': get_text('reNtceYn'),
                    'Í≥µÍ≥†Í∏∞Í¥ÄÎã¥ÎãπÏûê': get_text('ntceInsttOfclNm'),
                    'Îã¥ÎãπÏûêÏ†ÑÌôîÎ≤àÌò∏': get_text('ntceInsttOfclTelNo'),
                    'Îã¥ÎãπÏûêÏù¥Î©îÏùº': get_text('ntceInsttOfclEmailAdrs'),
                    'Ï∞∏Ï°∞Î≤àÌò∏': get_text('refNo'),
                    'Í≥µÍ≥†ÎßÅÌÅ¨': f"https://www.g2b.go.kr/pt/menu/selectSubFrame.do?bidNtceNo={bid_number}",
                    'ÏàòÏßëÏùºÏãú': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                    'ÏàòÏßëÎ∞©Î≤ï': 'Official API'
                }
                
                bid_data.append(bid_info)
                
            except Exception as e:
                print(f"‚ö†Ô∏è Error processing item: {e}")
                continue
        
        print(f"‚úÖ Processed {len(bid_data)} valid announcements")
        print(f"üö´ Excluded {excluded_count} private contracts")
        
        return bid_data
        
    except Exception as e:
        print(f"‚ùå XML parsing error: {e}")
        return []

def collect_bids_by_category(category: str, api_key: str) -> List[Dict]:
    """Collect bids for specific category"""
    if category not in API_OPERATIONS:
        print(f"‚ùå Unknown category: {category}")
        return []
    
    operation = API_OPERATIONS[category]
    
    # Calculate date range
    end_date = datetime.now()
    start_date = end_date - timedelta(days=SEARCH_DAYS)
    
    # Prepare API parameters according to documentation
    params = {
        'serviceKey': api_key,
        'numOfRows': '100',  # Results per page
        'pageNo': '1',       # Page number
        'type': 'xml',       # Response format
        'inqryDiv': '1',     # Query type: 1=registration date
        'inqryBgnDt': start_date.strftime('%Y%m%d%H%M'),  # YYYYMMDDHHMM format
        'inqryEndDt': end_date.strftime('%Y%m%d%H%M')     # YYYYMMDDHHMM format
    }
    
    print(f"üìÖ Search period: {start_date.strftime('%Y-%m-%d %H:%M')} ~ {end_date.strftime('%Y-%m-%d %H:%M')}")
    
    # Call API
    response_data = call_g2b_api(operation, params)
    
    if not response_data:
        return []
    
    # Parse XML response
    if 'xml_root' in response_data:
        return parse_xml_response(response_data['xml_root'])
    else:
        print("‚ùå Invalid response format")
        return []

def collect_all_bids(api_key: str) -> pd.DataFrame:
    """Collect bids from all categories"""
    print("üöÄ Starting comprehensive bid collection...")
    
    all_bids = []
    categories = ['goods', 'service', 'construction', 'foreign']
    category_names = {'goods': 'Î¨ºÌíà', 'service': 'Ïö©Ïó≠', 'construction': 'Í≥µÏÇ¨', 'foreign': 'Ïô∏Ïûê'}
    
    for category in categories:
        print(f"\nüìã Collecting {category_names[category]} announcements...")
        try:
            bids = collect_bids_by_category(category, api_key)
            if bids:
                # Add category information
                for bid in bids:
                    bid['ÏûÖÏ∞∞Î∂ÑÎ•ò'] = category_names[category]
                all_bids.extend(bids)
                print(f"‚úÖ {category_names[category]}: {len(bids)} announcements collected")
            else:
                print(f"‚ÑπÔ∏è {category_names[category]}: No announcements found")
        except Exception as e:
            print(f"‚ùå {category_names[category]} collection failed: {e}")
            continue
    
    if not all_bids:
        print("‚ùå No announcements collected from any category")
        return pd.DataFrame()
    
    # Create DataFrame
    df = pd.DataFrame(all_bids)
    
    # Remove duplicates based on announcement number
    initial_count = len(df)
    df = df.drop_duplicates(subset=['Í≥µÍ≥†Î≤àÌò∏'], keep='first')
    duplicate_count = initial_count - len(df)
    
    if duplicate_count > 0:
        print(f"üîÑ Removed {duplicate_count} duplicate announcements")
    
    print(f"üéØ Final result: {len(df)} unique announcements")
    
    return df

def print_detailed_stats(df: pd.DataFrame):
    """Print detailed collection statistics"""
    print("\n" + "=" * 80)
    print("üìä DETAILED COLLECTION STATISTICS")
    print("=" * 80)
    print(f"Total announcements: {len(df)}")
    
    if len(df) == 0:
        print("No data to analyze")
        return
    
    # Collection method breakdown
    if 'ÏàòÏßëÎ∞©Î≤ï' in df.columns:
        method_stats = df['ÏàòÏßëÎ∞©Î≤ï'].value_counts()
        print(f"\nüì° Collection method:")
        for method, count in method_stats.items():
            print(f"  ‚Ä¢ {method}: {count} items")
    
    # Category breakdown
    if 'ÏûÖÏ∞∞Î∂ÑÎ•ò' in df.columns:
        category_stats = df['ÏûÖÏ∞∞Î∂ÑÎ•ò'].value_counts()
        print(f"\nüìã Bid categories:")
        for category, count in category_stats.items():
            print(f"  ‚Ä¢ {category}: {count} announcements")
    
    # Contract method distribution
    if 'Í≥ÑÏïΩÎ∞©Î≤ï' in df.columns:
        contract_stats = df['Í≥ÑÏïΩÎ∞©Î≤ï'].value_counts()
        print(f"\nüèõÔ∏è Contract methods:")
        for method, count in contract_stats.items():
            print(f"  ‚Ä¢ {method}: {count} announcements")
    
    # Bid method distribution
    if 'ÏûÖÏ∞∞Î∞©Ïãù' in df.columns:
        bid_method_stats = df['ÏûÖÏ∞∞Î∞©Ïãù'].value_counts()
        print(f"\nüíº Bid methods:")
        for method, count in bid_method_stats.items():
            print(f"  ‚Ä¢ {method}: {count} announcements")
    
    # Top agencies
    if 'Í≥µÍ≥†Í∏∞Í¥Ä' in df.columns:
        agency_stats = df['Í≥µÍ≥†Í∏∞Í¥Ä'].value_counts().head(10)
        print(f"\nüè¢ Top 10 announcing agencies:")
        for agency, count in agency_stats.items():
            print(f"  ‚Ä¢ {agency}: {count} announcements")
    
    # Date distribution
    if 'ÏûÖÏ∞∞Í≥µÍ≥†Ïùº' in df.columns:
        df['Í≥µÍ≥†ÎÇ†Ïßú'] = pd.to_datetime(df['ÏûÖÏ∞∞Í≥µÍ≥†Ïùº'], errors='coerce').dt.date
        date_stats = df['Í≥µÍ≥†ÎÇ†Ïßú'].value_counts().sort_index()
        print(f"\nüìÖ Announcements by date:")
        for date, count in date_stats.items():
            if pd.notna(date):
                print(f"  ‚Ä¢ {date}: {count} announcements")
    
    print("=" * 80)

def save_results(df: pd.DataFrame) -> str:
    """Save results to CSV file"""
    if df.empty:
        print("‚ùå No data to save")
        return ""
    
    # Generate filename
    current_date = datetime.now().strftime('%Y%m%d_%H%M')
    filename = f'{OUTPUT_DIR}/G2B_ÏûÖÏ∞∞Í≥µÍ≥†_Í≥µÏãùAPI_{current_date}.csv'
    
    # Ensure output directory exists
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    
    # Save to CSV with Korean encoding
    df.to_csv(filename, index=False, encoding='utf-8-sig')
    
    print(f"üíæ Results saved to: {filename}")
    return filename

def main():
    """Main execution function"""
    print("üèõÔ∏è G2B Official API Solution - Ï°∞Îã¨Ï≤≠ ÎÇòÎùºÏû•ÌÑ∞ ÏûÖÏ∞∞Í≥µÍ≥†Ï†ïÎ≥¥ÏÑúÎπÑÏä§")
    print("=" * 80)
    print("üì° Using official Public Data Portal API")
    print("üîß Service: BidPublicInfoService")
    print("üåê Endpoint: https://apis.data.go.kr/1230000/ad/BidPublicInfoService")
    print("=" * 80)
    
    try:
        # Get API key
        api_key = get_api_key()
        if not api_key:
            print("‚ùå Cannot proceed without API key")
            print("üí° Get your API key from: https://www.data.go.kr/data/15129394/openapi.do")
            return
        
        # Collect all bid announcements
        df = collect_all_bids(api_key)
        
        if df.empty:
            print("‚ùå No announcements collected")
            print("üí° This could be due to:")
            print("   ‚Ä¢ Invalid API key")
            print("   ‚Ä¢ No announcements in the specified date range")
            print("   ‚Ä¢ API service temporarily unavailable")
            return
        
        # Save results
        filename = save_results(df)
        
        # Print statistics
        print_detailed_stats(df)
        
        # Success summary
        print(f"\n‚úÖ Collection completed successfully!")
        print(f"üìä Total announcements: {len(df)}")
        print(f"üíæ File saved: {filename}")
        
        # Usage tips
        print("\n" + "=" * 80)
        print("üí° USAGE TIPS")
        print("=" * 80)
        print("‚Ä¢ This solution uses the official G2B API from Public Data Portal")
        print("‚Ä¢ All data is authentic and real-time from government sources")
        print("‚Ä¢ No 403 errors or rate limiting issues")
        print("‚Ä¢ Data includes: Î¨ºÌíà, Ïö©Ïó≠, Í≥µÏÇ¨, Ïô∏Ïûê announcements")
        print("‚Ä¢ Private contracts (ÏàòÏùòÍ≥ÑÏïΩ) are automatically filtered out")
        print("‚Ä¢ Duplicate announcements are removed")
        print("‚Ä¢ For questions about API usage, contact: dobin@korea.kr")
        
    except Exception as e:
        print(f"‚ùå System error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()